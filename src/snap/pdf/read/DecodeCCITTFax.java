/*
 * Copyright (c) 2010, ReportMill Software. All rights reserved.
 */
package snap.pdf.read;
import java.io.*;
import java.util.Map;
import snap.pdf.PDFException;

/**
 * Decodes CCITTFax.
 */
public class DecodeCCITTFax {
    
    // The bit stream
    byte _allBits[];
    int _bitOffset;
    int _mark;
  
    // decode parameters
    int _K, _rows, _columns;
    int _numDamagedRowsAllowed;  
    boolean _byteAligned;
    boolean _eolRequired;
    boolean _eoblockRequired;
    boolean _blackIsOne;

  
/**
 * Decode a single image.
 */
public static byte[] bytesForCCITTFaxDecode(byte bytes[], int offset, int len, int K, int rows, int columns, 
      boolean byteAligned, boolean eolRequired, boolean eoblockRequired, boolean blackIsOne, int allowedDamagedRows)
{
    DecodeCCITTFax ccittFaxDecode = new DecodeCCITTFax(bytes, offset, K, rows, columns, allowedDamagedRows, 
       byteAligned, eolRequired, eoblockRequired,  blackIsOne);
    return ccittFaxDecode.decodeStream();
}

/**
 * Utility method to create a CCITTFaxDecoder from the stream's decodeParameters dictionary.
 */
public static DecodeCCITTFax createDecoder(Map params, byte bytes[], int offset, int len)
{
    // Every value has a default
    int K = 0;
    boolean eolRequired = false;
    boolean byteAligned = false;
    boolean eoblockRequired = true;
    boolean blackIsOne = false;
    int allowedDamagedRows = 0;
    int rows = 0, columns = 1728;
    
    // pull the parameter values out of the dictionary
    if (params != null) {
        Object pval = params.get("K");
        if (pval instanceof Number)
            K=((Number)pval).intValue();
        pval=params.get("EndOfLine");
        if (pval instanceof Boolean)
            eolRequired=((Boolean)pval).booleanValue();
        pval=params.get("EncodedByteAlign");
        if (pval instanceof Boolean)
            byteAligned=((Boolean)pval).booleanValue();
        pval = params.get("Columns");
        if (pval instanceof Number)
            columns=((Number)pval).intValue();
        pval = params.get("Rows");
        if (pval instanceof Number)
            rows=((Number)pval).intValue();
        pval=params.get("EndOfBlock");
        if (pval instanceof Boolean)
            eoblockRequired=((Boolean)pval).booleanValue();
        pval=params.get("BlackIs1");
        if (pval instanceof Boolean)
            blackIsOne=((Boolean)pval).booleanValue();
        pval = params.get("DamagedRowsBeforeError");
        if (pval instanceof Number)
            allowedDamagedRows=((Number)pval).intValue();
    }
    
    // return the new decoder
    return new DecodeCCITTFax(bytes, offset, K, rows, columns, allowedDamagedRows, 
            byteAligned, eolRequired, eoblockRequired, blackIsOne);
}

/**
 * Creates DecodeCCITTFax.
 */
public DecodeCCITTFax(byte bits[], int offset, int k, int rows, int columns, int numdamagedrows, 
        boolean aligned, boolean eolrequired, boolean eoblockrequired, boolean blackisone)
{
    _allBits = bits; _bitOffset = _mark=offset*8; _K = k;
    _rows = rows; _columns = columns; _numDamagedRowsAllowed = numdamagedrows; _byteAligned = aligned;
    _eolRequired = eolrequired; _eoblockRequired = eoblockrequired; _blackIsOne = blackisone;
}

/**
 * These arrays are binary trees of run lengths.  Branch nodes of the tree are represented
 *  by two consectutive ints in the tree.  If the value in the tree is positive,
 *  the child node is a branch node, and the number represents the index in this
 *  table where that child node can be found.  
 *  If the value is negative, it is a leaf node and the run length for the bit string
 *  is the absolute value of that number.
 *  Two special values exist in the table. -9999 indicates a bit string that isn't
 *  represented in the table. -1000 is the EOL.
 *  Run lengths 0-63 encode that many white or black pixels.
 *  Run lengths >63 encode that many + the value of the next code (which should be <64)
 *  Run length 2560 encodes 2560 + next 1 or 2 codes, and may be repeated many times.
 *  
 *  searching the table is a simple matter of walking through the bits:
 *  
 *  int table_index=0;
 *  do {
 *    if (getNextBit()) ++table_index; // choose left node for 0 bit, right node for 1 bit
 *    table_index=ccittRunLengths[table_index]; // get the node
 *    } while(table_index>0); //continue walking down the tree until a negative (or 0) number is found
 *   return -table_index;
 *  
 *  These arrays were generated by CCITTreeBuilder.java
 */
static int ccittRunLengths_white[] = {
    2, 192, 4, 116, 6, 80, 8, 60, 10, 54, 12, 50, 14, 48, 16, 24, 
    18, -9999, 20, -9999, 22, -9999, -9999, -1000, 26, 38, 28, 32, -1792, 30, -1984, -2048, 
    34, 36, -2112, -2176, -2240, -2304, 40, 42, -1856, -1920, 44, 46, -2368, -2432, -2496, -2560, 
    -29, -30, 52, -22, -45, -46, 56, -13, -23, 58, -47, -48, 62, 74, 64, 68, 
    -20, 66, -33, -34, 70, 72, -35, -36, -37, -38, 76, -1, -19, 78, -31, -32, 
    82, 102, 84, 90, -12, 86, 88, -26, -53, -54, 92, 98, 94, 96, -39, -40, 
    -41, -42, 100, -21, -43, -44, 104, -10, 106, 110, -28, 108, -61, -62, 112, 114, 
    -63, 0, -320, -384, 118, 156, 120, 136, -11, 122, 124, 128, -27, 126, -59, -60, 
    130, -18, 132, 134, -1472, -1536, -1600, -1728, 138, 148, 140, 144, -24, 142, -49, -50, 
    146, -25, -51, -52, 150, -192, 152, 154, -55, -56, -57, -58, 158, -2, 160, 170, 
    -1664, 162, 164, 166, -448, -512, 168, -640, -704, -768, 172, 184, 174, 178, -576, 176, 
    -832, -896, 180, 182, -960, -1024, -1088, -1152, 186, -256, 188, 190, -1216, -1280, -1344, -1408, 
    194, 206, 196, 200, -3, 198, -128, -8, 202, -4, -9, 204, -16, -17, 208, 214, 
    -5, 210, 212, -64, -14, -15, -6, -7};

static int ccittRunLengths_black[] = {
    2, 214, 4, 212, 6, 210, 8, 206, 10, 164, 12, 114, 14, 48, 16, 24, 
    18, -9999, 20, -9999, 22, -9999, -9999, -1000, 26, 38, 28, 32, -1792, 30, -1984, -2048, 
    34, 36, -2112, -2176, -2240, -2304, 40, 42, -1856, -1920, 44, 46, -2368, -2432, -2496, -2560, 
    50, 82, 52, 64, -18, 54, 56, 60, -52, 58, -640, -704, 62, -55, -768, -832, 
    66, 76, 68, 72, -56, 70, -1280, -1344, 74, -59, -1408, -1472, 78, -24, -60, 80, 
    -1536, -1600, 84, 100, 86, 92, -25, 88, 90, -320, -1664, -1728, 94, 96, -384, -448, 
    98, -53, -512, -576, 102, -64, 104, 108, -54, 106, -896, -960, 110, 112, -1024, -1088, 
    -1152, -1216, 116, 140, -13, 118, 120, 132, 122, 126, -23, 124, -50, -51, 128, 130, 
    -44, -45, -46, -47, 134, -16, 136, 138, -57, -58, -61, -256, 142, -14, 144, 152, 
    -17, 146, 148, 150, -48, -49, -62, -63, 154, 160, 156, 158, -30, -31, -32, -33, 
    162, -22, -40, -41, 166, 168, -10, -11, 170, -12, 172, 186, -15, 174, 176, 182, 
    178, 180, -128, -192, -26, -27, 184, -19, -28, -29, 188, 200, 190, 194, -20, 192, 
    -34, -35, 196, 198, -36, -37, -38, -39, 202, 0, -21, 204, -42, -43, 208, -7, 
    -9, -8, -6, -5, -1, -4, -3, -2};


// Special 1D encoding flags
public static final int EndOfTheLine = -1000;
// 2D encoding modes
public static final int PassMode = 1;
public static final int Horizontal = 2;
public static final int Vertical0 = 3;
public static final int VerticalRight1 = 4;
public static final int VerticalRight2 = 5;
public static final int VerticalRight3 = 6;
public static final int VerticalLeft1 = 7;
public static final int VerticalLeft2 = 8;
public static final int VerticalLeft3 = 9;
public static final int UncompressedMode = 10;

// 2D encoding.  Negative integers correspond to one of the modes above.
static int ccittCodeWords2d[] = {
    2, -3, 4, 34, 6, -2, 8, -1, 10, 32, 12, 30, 14, 24, 16, -9999, 
    18, -9999, 20, -9999, 22, -9999, -9999, -1000, -9999, 26, -9999, 28, -9999, -10, -9, -6, 
    -8, -5, -7, -4};


// Read the next codeword from the stream.  table is one of the above trees.
// Returns the codeword or -1 for EOF
public int getNextCodeword(int table[])
{
    int byteOffset=_bitOffset/8;
    int mask = 1<<(7-(_bitOffset%8));
    int abyte;
    int treeindex=0;
    if (byteOffset>=_allBits.length)
      return -1;
    abyte = _allBits[byteOffset];
    while(true) {
         if ((abyte & mask) != 0)
            ++treeindex;
        treeindex=table[treeindex];
        ++_bitOffset;
        if (treeindex==-9999)
            throw new PDFException("Error decoding CCITTFaxDecode stream");
        else if (treeindex==EndOfTheLine)
            return EndOfTheLine;
        else if (treeindex<=0)
          return -treeindex;
        mask>>=1;
        if (mask==0) {
            if (++byteOffset>=_allBits.length)
                // incomplete codeword, but no more bits.  returns eof
                return -1;
            abyte = _allBits[byteOffset];
            mask = 128;
        }
    }
}

/** Interprets next n codewords as an integer.
 * Rules are: numbers less than 64 are low digits.
 *            numbers between 64 and 2559 require one additional low digit.
 *            2560 requires an additional number, containing any number of digits.
 **/
public int getNextInt(int table[])
{
    boolean need_more_digits=false;
    int i=0,c;
    
    while(true) {
        c = getNextCodeword(table);
        if (c<0) { // should only happen for EOL or EOF
            throw new PDFException("premature EOL encountered in CCITTFaxDecode stream");
        }
        if (need_more_digits) {
            if (c>63)
                throw new PDFException("Error decoding CCITTFaxDecodeStream");
            i+=c;
            return i;
        }
        else {
            if (c<=63)
                return i+c;
            i+=c;
            if (c != 2560)
                need_more_digits=true;
        }
    }
}

/**Skips over any extra padding bits at the end of a byte. */
public void byteAlignStream() { _bitOffset = (_bitOffset+7)&~7;}

/** Mark the current point in the bitstream.  Use backup() to return to this point. */
public void mark() { _mark = _bitOffset; }
/** Back the stream up to the marked position */
public void backup() { _bitOffset = _mark; }

/** Decode the entire image at once */
public byte[] decodeStream()
{
    ByteArrayOutputStream outstream = new ByteArrayOutputStream(64);
    try {
        decodeStream(outstream);
    }
    catch (Exception e) {
        System.err.println("Error decoding CCITTFax image stream");
        return null;
    }
    return outstream.toByteArray();
}

/** Decode, writing image bytes to outstream */
public void decodeStream(OutputStream outstream) throws PDFException, IOException
{
    byte scanline[] = new byte[_columns];
    int initialStreamPosition = _bitOffset; 

    // Pure 1D encoding
    if (_K==0) {
        while(decodeScanline1D(scanline)) {
            writeScanline(outstream, scanline);
            if (_byteAligned)
                byteAlignStream();
        }
    }
    //Pure 2D encoding
    else if (_K<0) {
        // 2D encoding always uses the last scanline as a reference.
        // For the first scanline, the reference is a pure white scanline
        for(int i=0; i<_columns; ++i)
            scanline[i]=1;
        while(decodeScanline2D(scanline)) {
            writeScanline(outstream, scanline);
            if (_byteAligned)
                byteAlignStream();
        }
    }
    else {
        // Mixed mode takes 1 1d line, followed by K-1 2d lines.
        // The only trick would be to check how the end of stream is handled
        _bitOffset = initialStreamPosition;
        throw new PDFException("Mixed 1d&2d CCITTFaxDecode mode not implemented yet");
    }

    outstream.flush();    
    
    // reset the input stream so the next call to decodeStream will start over
    _bitOffset = initialStreamPosition;
}

// There are two different encoding schemes which can used together in a bit stream.
// The 1D encoding (Group 3) takes a scanline and alternates between black and white
// runs by encoding a run length code.
// The 2D encoding (Group 4) works on mulitple scanlines by encoding a scanline with
// 1D encoding (for mixed Group 3 & 4 mode) or by initializing to white (Pure Group 4)
// and then encoding later scanlines using codes to specify diffrerences
// from previous scanlines.
// 
// Returns true for success, false for eof.
public boolean decodeScanline1D(byte outdata[])
{
    int codeword_trees[][] = {ccittRunLengths_black, ccittRunLengths_white};
    int atree[];
    int x=0;
    int runcolor=1; //0 for black, 1 for white
    int codeword;
    int runlength=0;
    boolean need_more_digits=false;
    int num_2560s=0;
    int num_eols=0;
    
    atree = codeword_trees[runcolor];
    // outdata is assumed to be big enough to hold x 8bit pixels, so no bounds checking on the array is done
    while(x<_columns) {
        codeword = getNextCodeword(atree);
       
        if (codeword==EndOfTheLine) {
            //EOL before getting any row data may be part of an EndOfBlock (6 EOLs)
            if (x==0) {
                for(num_eols=1; num_eols<6; ++num_eols) {
                    codeword = getNextCodeword(atree);
                    if (codeword==-1) return false;
                    else if (codeword != EndOfTheLine)
                        throw new PDFException("Unexpected EOL in CCITTFaxDecode stream");
                }
                // got an eob - return false (for end of data)
                return false;
            }
            else // EOL in the middle of the row is an error
                throw new PDFException("Unexpected EOL in CCITTFaxDecodeStream");
        }
        //large run lengths can be encoded as 2560+2560+2560...+m, where m is 1 or 2 digit code
        else if (codeword==2560) {
            if (need_more_digits)
                throw new PDFException("Error decoding CCITTFaxDecode stream");
            ++num_2560s;
        }
        //Run lengths between 64 & 2560 consist of 2 codes, and this code is the high digit
        else if (codeword>=64) {
            runlength=codeword;
            if (need_more_digits)
                throw new PDFException("Error decoding CCITTFaxDecode stream");
            need_more_digits=true;
        }
        //A run length between 0 and 63
        else if (codeword != -1) {
            // If previous code word was for a high digit, add the low digit in
            if (need_more_digits)
                runlength+=codeword;
            else
                runlength=codeword;
            // add in chain of 2560s
            runlength += 2560*num_2560s;
            if (x+runlength>_columns) 
                throw new PDFException("Error decoding CCITTFaxDecode stream");
            // fill the output with the colors.  Notice it's 8bits per pixel, 2 colors
            for(int r=0; r<runlength; ++r)
                outdata[x++]=(byte)runcolor;
            
            // reset everthing for the next run
            runcolor = 1-runcolor;
            atree = codeword_trees[runcolor];
            need_more_digits=false;
            num_2560s=0;
        }
        //EOF
        else {
            if (x==0) 
                return false;
            else 
                throw new PDFException("premature end of CCITTFaxDecode stream");
        }
    }
    // Filled the scanline.  Check for EOL
    mark();
    if (getNextCodeword(atree) != EndOfTheLine) {
        if (_eolRequired)
            throw new PDFException("No End-of-line marker found in CCITTFaxDecode stream");
        else
            // It wasn't required to be there, so back up to the last point in the stream.
            backup();
    }
    return true;
    
}

//Used by 2D decoder
//Finds b1 & b2 (returned as elements b[1] and b[2], respectively)
//on the reference scanline, starting from pixel a0
public void locateReferenceMarks(byte scanline[], int a0, byte a0color, int b[])
{
    int x;
    int b0=a0+1;
    byte bcolor=0,previous;
    // b1 is defined as first 'changing element' to the right of a0 which
    // is a different color from a0
    // A changing element is a pixel whose color is different from the 
    // pixel to its left.
    // The pixel at -1 is defined to be white, so scanline[0] is a changing
    // element if it is black.
    
    //search for b1
    for(x=b0;x<scanline.length;++x) {
        bcolor=scanline[x];
        previous = x==0 ? 1 : scanline[x-1];
        if (bcolor != previous) {
            // a changing element.  If its different from a0color,
            // we've found b1
            if (bcolor != a0color) {
                b[1]=x;
                break;
            }
        }
    }
    // If b1 not found (all pixels were the same color, for instance) set 
    // b1 & b2 to the pixel after the last one in the line.
    if (x==scanline.length) {
        b[1]=b[2]=x;
    }
    else {
        //find b2
        while(++x<scanline.length)
            if (scanline[x]!=bcolor) {
                b[2]=x;
                break;
            }
        if (x==scanline.length)
            b[2]=x;
    }
}

/** 2D decoder.  outdata is a buffer which the new scanline will be written to.  
 * On input, however, outdata should have the bits for the previous scanline.
 * The 2D encoder will include codewords which make reference to the previous
 * scanline.
 * For the very first scaneline, outdata should be initialized to all white.
 **/
public boolean decodeScanline2D(byte outdata[])
{
    int codeword_trees[][] = {ccittRunLengths_black, ccittRunLengths_white};
    int x=0;
    // a0 starts off to the left of first pixel and is defined as white
    int a0=-1;
    byte a0Color=1;
    int a1,a2;
    int b[] = new int[3];
    int codeword;
    
    
    while(x<_columns) {
        codeword = getNextCodeword(ccittCodeWords2d);
        //EOD due to unused bits in last byte of data
        if ((codeword<0)&&(x==0)) return false;
        //EOFB is 2 EOLs in a row.  No other EOLs are valid in 2d mode
        if (codeword==EndOfTheLine) {
            if ((x==0) && (getNextCodeword(ccittCodeWords2d)==EndOfTheLine))
                return false;
            else 
                throw new PDFException("EOL encountered in CCITTFaxDecode stream");
        }
        // Horizontal mode explicity codes a0a1 and a1a2
        else if (codeword==Horizontal) {
            if (a0==-1) // first pixel on line
                a0=0;
            a1 = a0+getNextInt(codeword_trees[a0Color]);
            a2 = a1+getNextInt(codeword_trees[1-a0Color]);
            
            while(x<a1)
                outdata[x++]=a0Color;
            while(x<a2)
                outdata[x++]=(byte)(1-a0Color);
            a0=a2;
        }
        else if (codeword==UncompressedMode) {
            throw new PDFException("UncompressedMode not implemented yet");
        }
        else {
            // The rest of these codes make reference to b[1] & b[2] on the line above
            locateReferenceMarks(outdata, a0, a0Color, b);
            if (codeword==PassMode) {
                while(x<b[2]) 
                    outdata[x++]=a0Color;
                a0=b[2];
            }
            else {
                switch(codeword) {
                case Vertical0 : break;
                case VerticalRight1 : b[1]+=1; break;
                case VerticalRight2 : b[1]+=2; break;
                case VerticalRight3 : b[1]+=3; break;
                case VerticalLeft1 : b[1]-=1; break;
                case VerticalLeft2 : b[1]-=2; break;
                case VerticalLeft3 : b[1]-=3; break;
                default :
                    throw new PDFException("Invalid data in CCITTFaxDecode stream");
                }
                // I don't think this should ever happen in a valid stream
                if (b[1]>outdata.length)
                    b[1]=outdata.length;
                a0=b[1];
                while(x<b[1])
                    outdata[x++]=a0Color;
                a0Color=(byte)(1-a0Color);
            }
        }
    }
    return true;
}

/** Write the decoded scanline to a stream. */
public void writeScanline(OutputStream out, byte scanline[]) throws IOException
{
    out.write(scanline);
}

/** Get the width of the decompressed image */
public int getWidth() { return _columns; }

/** Get the height of the decompressed image */
public int getHeight() { return _rows; }

/** Returns whether a pixel value or 1 should be interpreted as black or white */
public boolean blackIsOne() { return _blackIsOne; }
    
/** Set the dimensions manually */
public void setDimensions(int width, int height)
{
    // We don't necessarily know what the height of the
    // decompressed image is until after decompression,
    // but we do know the width.
    if (width != _columns)
        throw new PDFException("Illegal values for CCITTFaxDecode image width");
    
    // If we already think we know what the rows are, _rows will be non-zero
    if ((_rows != 0) && (_rows != height))
        throw new PDFException("Illegal values for CCITTFaxDecode image height");

    _rows = height;
}

}
